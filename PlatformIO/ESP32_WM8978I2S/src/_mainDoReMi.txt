// Arduino Zero / Feather M0 I2S audio tone generation example.
// Author: Tony DiCola
//
// Connect an I2S DAC or amp (like the UDA1334A) to the Arduino Zero
// and play back simple sine, sawtooth, triangle, and square waves.
// Makes your Zero sound like a NES!
//
// NOTE: The I2S signal generated by the Zero does NOT have a MCLK /
// master clock signal.  You must use an I2S receiver that can operate
// without a MCLK signal (like the UDA1334A).
//
// For an Arduino Zero / Feather M0 connect it to you I2S hardware as follows:
// - Digital 0 -> I2S LRCLK / FS (left/right / frame select clock)
// - Digital 1 -> I2S BCLK / SCLK (bit / serial clock)
// - Digital 9 -> I2S DIN / SD (data output)
// - Ground
//
// Released under a MIT license: https://opensource.org/licenses/MIT
//
//
//
// Modified by Jimmy.Su @Apr-20-2020
// Change to 16bit I2S
//
#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include "wm8978.h" //borrowed from the NuvotonDuino example
#include "I2S.h"

#include <Ticker.h>
Ticker myBlinker;
void blink()
{
  pinMode(22, OUTPUT);
  digitalWrite(22, !(digitalRead(22)));
}

#define SAMPLERATE_HZ 48000  // The sample rate of the audio.  Higher sample rates have better fidelity,
                             // but these tones are so simple it won't make a difference.  44.1khz is
                             // standard CD quality sound.

#define AMPLITUDE     ((1<<15)-1)   // Set the amplitude of generated waveforms.  This controls how loud
                             // the signals are, and can be any value from 0 to 2**31 - 1.  Start with
                             // a low value to prevent damaging speakers!

#define WAV_SIZE      256    // The size of each generated waveform.  The larger the size the higher
                             // quality the signal.  A size of 256 is more than enough for these simple
                             // waveforms.


// Define the frequency of music notes (from http://www.phy.mtu.edu/~suits/notefreqs.html):
#define C4_HZ      261.63
#define D4_HZ      293.66
#define E4_HZ      329.63
#define F4_HZ      349.23
#define G4_HZ      392.00
#define A4_HZ      440.00
#define B4_HZ      493.88

// Define a C-major scale to play all the notes up and down.
float scale[] = { C4_HZ, D4_HZ, E4_HZ, F4_HZ, G4_HZ, A4_HZ, B4_HZ, A4_HZ, G4_HZ, F4_HZ, E4_HZ, D4_HZ, C4_HZ };

// Store basic waveforms in memory.
int16_t sine[WAV_SIZE]     = {0};
int16_t sawtooth[WAV_SIZE] = {0};
int16_t triangle[WAV_SIZE] = {0};
int16_t square[WAV_SIZE]   = {0};



void generateSine(int16_t amplitude, int16_t* buffer, uint16_t length) {
  // Generate a sine wave signal with the provided amplitude and store it in
  // the provided buffer of size length.
  for (int i=0; i<length; ++i) {
    buffer[i] = int16_t(float(amplitude)*sin(1.0*PI*(1.0/length)*i));
    Serial.printf("%d ",buffer[i]);
    }
  Serial.println();
}
void generateSawtooth(int16_t amplitude, int16_t* buffer, uint16_t length) {
  // Generate a sawtooth signal that goes from -amplitude/2 to amplitude/2
  // and store it in the provided buffer of size length.
  float delta = float(amplitude)/float(length);
  for (int i=0; i<length; ++i) {
    buffer[i] = -(amplitude/2.0)+delta*i;
    Serial.printf("%d ",buffer[i]);
    }
  Serial.println();
}

void generateTriangle(int16_t amplitude, int16_t* buffer, uint16_t length) {
  // Generate a triangle wave signal with the provided amplitude and store it in
  // the provided buffer of size length.
  float delta = float(amplitude)/float(length);
  for (int i=0; i<length/2; ++i) {
    buffer[i] = -(amplitude/2)+delta*i;
    }
    for (int i=length/2; i<length; ++i) {
    buffer[i] = (amplitude/2)-delta*(i-length/2);
    }
}

void generateSquare(int16_t amplitude, int16_t* buffer, uint16_t length) {
  // Generate a square wave signal with the provided amplitude and store it in
  // the provided buffer of size length.
  for (int i=0; i<length/2; ++i) {
    buffer[i] = -(amplitude/2);
    }
    for (int i=length/2; i<length; ++i) {
    buffer[i] = (amplitude/2);
    }
}

#define BLOCK_SIZE 16
void i2sVU() {
  // Read multiple samples at once and calculate the sound pressure
  int16_t samples[BLOCK_SIZE];
  //int num_bytes_read = i2s_read_bytes((i2s_port_t)0, (char *)samples, BLOCK_SIZE, portMAX_DELAY); 
  int num_bytes_read = I2S_Read(samples, (int)BLOCK_SIZE);
  int samples_read = num_bytes_read / 8;
  if (samples_read > 0) {
    float mean = 0;
    for (int i = 0; i < samples_read; ++i) {
      //mean += (samples[i] >> 14);
      mean += (samples[i] );
      }
    mean /= samples_read;

    float maxsample = -1e8, minsample = 1e8;
    for (int i = 0; i < samples_read; ++i) {
      minsample = min(minsample, samples[i] - mean);
      maxsample = max(maxsample, samples[i] - mean);
      }
    //Serial.println(maxsample - minsample);
    Serial.printf("mean:%f7.1 max:%f7.1 min:%f7.1\n", mean, maxsample, minsample);
    }
}


void playWave(int16_t* buffer, uint16_t length, float frequency, float seconds) {
  // Play back the provided waveform buffer for the specified
  // amount of seconds.
  // First calculate how many samples need to play back to run
  // for the desired amount of seconds.
  uint32_t iterations = seconds*SAMPLERATE_HZ;
  // Then calculate the 'speed' at which we move through the wave
  // buffer based on the frequency of the tone being played.
  float delta = (frequency*length)/float(SAMPLERATE_HZ);
  // Now loop through all the samples and play them, calculating the
  // position within the wave buffer for each moment in time.
  size_t written;
  uint32_t i;
  for (i=0; i<iterations; ++i) {
    uint16_t pos = uint16_t(i*delta) % length;
    int16_t sample = buffer[pos];
    // Duplicate the sample so it's sent to both the left and right channel.
    // It appears the order is right channel, left channel if you want to write
    // stereo sound.
    //i2s.write(sample, sample);
    i2s_write((i2s_port_t)0, (const char *)&sample, 2, &written, 100);    //right
    i2s_write((i2s_port_t)0, (const char *)&sample, 2, &written, 100);    //left
    }
  //i2sVU();  
}



/****************************************
 * WM8978 I2C SETUP
 * Uses the WM8978 I2C library distributed with the NuovoDuino
  *****************************************/
  void wm8978Setup() {
  
    Wire.begin(19,18); //(SDA,SCL,Frequency)
  
    WM8978_Init();

    WM8978_ADDA_Cfg(1, 1);
    WM8978_Input_Cfg(1, 0, 0);
    WM8978_Output_Cfg(1, 0);
    WM8978_MIC_Gain(0);
    WM8978_AUX_Gain(0);
    WM8978_LINEIN_Gain(0);
    WM8978_SPKvol_Set(10);
    WM8978_HPvol_Set(10, 10); //0-63
    WM8978_EQ_3D_Dir(0);
    WM8978_EQ1_Set(0, 24);
    WM8978_EQ2_Set(0, 24);
    WM8978_EQ3_Set(0, 24);
    WM8978_EQ4_Set(0, 24);
    WM8978_EQ5_Set(0, 24);
    WM8978_I2S_Cfg(2, 0);
} //wm8978Setup

void setup() {
  // Configure serial port.
  Serial.begin(115200);
  delay(100);
  myBlinker.attach_ms(500, blink);

  // Generate waveforms.
  Serial.println("\nSine wave:");
  generateSine(AMPLITUDE, sine, WAV_SIZE);
  Serial.println("\nSawtooth wave:");
  generateSawtooth(AMPLITUDE, sawtooth, WAV_SIZE);
  generateTriangle(AMPLITUDE, triangle, WAV_SIZE);
  generateSquare(AMPLITUDE, square, WAV_SIZE);

  Serial.println("\nInit WM8978");
  wm8978Setup();
  Serial.println("Init I2S...");
  I2S_Init();
  Serial.println("Starting DoReMi...\n");
  
}

void loop() {
  Serial.println("Sine wave");
  for (int i=0; i<sizeof(scale)/sizeof(float); ++i) {
    // Play the note for a quarter of a second.
    playWave(sine, WAV_SIZE, scale[i], 0.25);
    // Pause for a tenth of a second between notes.
    delay(10);
  }
  Serial.println("Sawtooth wave");
  for (int i=0; i<sizeof(scale)/sizeof(float); ++i) {
    // Play the note for a quarter of a second.
    playWave(sawtooth, WAV_SIZE, scale[i], 0.25);
    // Pause for a tenth of a second between notes.
    delay(10);
  }
  Serial.println("Triangle wave");
  for (int i=0; i<sizeof(scale)/sizeof(float); ++i) {
    // Play the note for a quarter of a second.
    playWave(triangle, WAV_SIZE, scale[i], 0.25);
    // Pause for a tenth of a second between notes.
    delay(10);
  }
  Serial.println("Square wave");
  for (int i=0; i<sizeof(scale)/sizeof(float); ++i) {
    // Play the note for a quarter of a second.
    playWave(square, WAV_SIZE, scale[i], 0.25);
    // Pause for a tenth of a second between notes.
    delay(10);
  }
  
}